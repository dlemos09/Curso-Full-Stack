================================================================================
                              AULA 11 - DIA 11
                        FUN√á√ïES E PROCEDIMENTOS ARMAZENADOS
================================================================================

HOR√ÅRIO: 13:30 - 17:30 | DATA: _____/_____/_____

OBJETIVOS:
‚úì Criar fun√ß√µes SQL personalizadas
‚úì Desenvolver fun√ß√µes em PL/pgSQL
‚úì Implementar procedimentos armazenados
‚úì Utilizar par√¢metros IN, OUT, INOUT

CRONOGRAMA:
13:30-14:30 ‚Üí Fun√ß√µes SQL
14:30-15:30 ‚Üí PL/pgSQL B√°sico
15:30-15:45 ‚Üí Intervalo
15:45-16:30 ‚Üí Procedimentos
16:30-17:30 ‚Üí Pr√°tica

================================================================================
1. FUN√á√ïES SQL
================================================================================

CONCEITO:
Fun√ß√µes SQL s√£o blocos de c√≥digo reutiliz√°veis que retornam valores.
Podem ser usadas em SELECT, WHERE, etc.

SINTAXE B√ÅSICA:
CREATE OR REPLACE FUNCTION nome_funcao(parametros)
RETURNS tipo_retorno
LANGUAGE SQL
AS $$
    -- c√≥digo SQL aqui
$$;

--------------------------------------------------------------------------------
EXEMPLO 1: Fun√ß√£o Simples
--------------------------------------------------------------------------------

-- Fun√ß√£o para calcular desconto
CREATE OR REPLACE FUNCTION calcular_desconto(
    preco DECIMAL,
    percentual DECIMAL
)
RETURNS DECIMAL
LANGUAGE SQL
AS $$
    SELECT ROUND(preco * (1 - percentual/100), 2);
$$;

-- üí° $$ √© o delimitador de string, evita problemas com aspas internas
-- üí° ROUND(valor, 2) arredonda para 2 casas decimais

-- Usando a fun√ß√£o:
SELECT 
    nome,
    preco,
    calcular_desconto(preco, 10) AS preco_com_10porcento,
    calcular_desconto(preco, 25) AS preco_com_25porcento
FROM produtos;

--------------------------------------------------------------------------------
EXEMPLO 2: Fun√ß√£o com M√∫ltiplos Par√¢metros
--------------------------------------------------------------------------------

-- Calcular frete baseado em peso e dist√¢ncia
CREATE OR REPLACE FUNCTION calcular_frete(
    peso_kg DECIMAL,
    distancia_km INTEGER,
    taxa_base DECIMAL DEFAULT 5.00
)
RETURNS DECIMAL
LANGUAGE SQL
AS $$
    SELECT taxa_base + (peso_kg * 0.50) + (distancia_km * 0.10);
$$;

-- üí° DEFAULT 5.00 ‚Üí par√¢metro opcional com valor padr√£o

-- Uso:
SELECT calcular_frete(2.5, 100);         -- usa taxa_base padr√£o
SELECT calcular_frete(2.5, 100, 8.00);   -- taxa_base customizada

--------------------------------------------------------------------------------
EXEMPLO 3: Fun√ß√£o que Retorna Tabela
--------------------------------------------------------------------------------

-- Retornar produtos de uma categoria
CREATE OR REPLACE FUNCTION produtos_categoria(cat_id INTEGER)
RETURNS TABLE(
    produto_nome VARCHAR,
    preco DECIMAL,
    estoque INTEGER
)
LANGUAGE SQL
AS $$
    SELECT nome, preco, estoque
    FROM produtos
    WHERE categoria_id = cat_id
    AND ativo = TRUE
    ORDER BY nome;
$$;

-- üí° RETURNS TABLE ‚Üí fun√ß√£o retorna conjunto de linhas
-- üí° Pode ser usada como uma tabela virtual

-- Uso:
SELECT * FROM produtos_categoria(3);

================================================================================
2. FUN√á√ïES PL/pgSQL
================================================================================

CONCEITO:
PL/pgSQL √© a linguagem procedural do PostgreSQL.
Permite: vari√°veis, condicionais, loops, tratamento de erros.

SINTAXE:
CREATE OR REPLACE FUNCTION nome(parametros)
RETURNS tipo
LANGUAGE plpgsql
AS $$
DECLARE
    -- declara√ß√£o de vari√°veis
BEGIN
    -- l√≥gica da fun√ß√£o
    RETURN valor;
END;
$$;

--------------------------------------------------------------------------------
EXEMPLO 4: Fun√ß√£o com Vari√°veis
--------------------------------------------------------------------------------

-- Calcular total do pedido com desconto progressivo
CREATE OR REPLACE FUNCTION total_pedido_com_desconto(pedido_id INTEGER)
RETURNS DECIMAL
LANGUAGE plpgsql
AS $$
DECLARE
    v_total DECIMAL;
    v_desconto DECIMAL := 0;  -- := atribui valor inicial
BEGIN
    -- Calcular total
    SELECT SUM(quantidade * preco_unitario)
    INTO v_total  -- INTO coloca resultado na vari√°vel
    FROM itens_pedido
    WHERE itens_pedido.pedido_id = total_pedido_com_desconto.pedido_id;
    
    -- Desconto progressivo
    IF v_total > 1000 THEN
        v_desconto := 0.15;  -- 15%
    ELSIF v_total > 500 THEN
        v_desconto := 0.10;  -- 10%
    ELSIF v_total > 200 THEN
        v_desconto := 0.05;  -- 5%
    END IF;
    
    RETURN ROUND(v_total * (1 - v_desconto), 2);
END;
$$;

-- üí° DECLARE ‚Üí se√ß√£o de declara√ß√£o de vari√°veis
-- üí° := ‚Üí operador de atribui√ß√£o
-- üí° INTO ‚Üí captura resultado de SELECT em vari√°vel

-- Uso:
SELECT 
    id,
    total_pedido_com_desconto(id) AS total_final
FROM pedidos;

--------------------------------------------------------------------------------
EXEMPLO 5: Fun√ß√£o com LOOP
--------------------------------------------------------------------------------

-- Calcular juros compostos
CREATE OR REPLACE FUNCTION calcular_juros_compostos(
    valor_inicial DECIMAL,
    taxa_mensal DECIMAL,
    meses INTEGER
)
RETURNS DECIMAL
LANGUAGE plpgsql
AS $$
DECLARE
    v_valor DECIMAL := valor_inicial;
    v_mes INTEGER := 1;
BEGIN
    WHILE v_mes <= meses LOOP
        v_valor := v_valor * (1 + taxa_mensal/100);
        v_mes := v_mes + 1;
    END LOOP;
    
    RETURN ROUND(v_valor, 2);
END;
$$;

-- üí° WHILE ... LOOP ‚Üí estrutura de repeti√ß√£o
-- üí° √ötil para c√°lculos iterativos

-- Uso:
SELECT calcular_juros_compostos(1000, 2, 12);  -- R$ 1000 a 2% a.m. por 12 meses

--------------------------------------------------------------------------------
EXEMPLO 6: Fun√ß√£o com EXCEPTION
--------------------------------------------------------------------------------

-- Buscar produto com tratamento de erro
CREATE OR REPLACE FUNCTION buscar_preco_produto(produto_id INTEGER)
RETURNS DECIMAL
LANGUAGE plpgsql
AS $$
DECLARE
    v_preco DECIMAL;
BEGIN
    SELECT preco INTO STRICT v_preco
    FROM produtos
    WHERE id = produto_id;
    
    RETURN v_preco;
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE NOTICE 'Produto % n√£o encontrado', produto_id;
        RETURN 0;
    WHEN TOO_MANY_ROWS THEN
        RAISE EXCEPTION 'M√∫ltiplos produtos encontrados!';
END;
$$;

-- üí° STRICT ‚Üí garante exatamente 1 linha (sen√£o lan√ßa exce√ß√£o)
-- üí° EXCEPTION ‚Üí bloco de tratamento de erros
-- üí° RAISE NOTICE ‚Üí mensagem de aviso
-- üí° RAISE EXCEPTION ‚Üí interrompe execu√ß√£o

-- Uso:
SELECT buscar_preco_produto(999);  -- produto inexistente

================================================================================
3. PAR√ÇMETROS OUT E INOUT
================================================================================

CONCEITO:
- IN: entrada (padr√£o)
- OUT: sa√≠da (retorna valor)
- INOUT: entrada e sa√≠da

--------------------------------------------------------------------------------
EXEMPLO 7: Par√¢metros OUT
--------------------------------------------------------------------------------

-- Estat√≠sticas de cliente
CREATE OR REPLACE FUNCTION estatisticas_cliente(
    IN cliente_id INTEGER,
    OUT total_pedidos INTEGER,
    OUT valor_total DECIMAL,
    OUT ticket_medio DECIMAL
)
LANGUAGE plpgsql
AS $$
BEGIN
    SELECT 
        COUNT(*),
        COALESCE(SUM(valor_total), 0),
        COALESCE(AVG(valor_total), 0)
    INTO total_pedidos, valor_total, ticket_medio
    FROM pedidos
    WHERE pedidos.cliente_id = estatisticas_cliente.cliente_id;
END;
$$;

-- üí° OUT ‚Üí par√¢metros de sa√≠da, n√£o precisa RETURN
-- üí° Fun√ß√£o retorna RECORD (registro com m√∫ltiplos valores)

-- Uso:
SELECT * FROM estatisticas_cliente(5);

-- Ou capturar valores:
SELECT total_pedidos, ticket_medio 
FROM estatisticas_cliente(5);

--------------------------------------------------------------------------------
EXEMPLO 8: Par√¢metro INOUT
--------------------------------------------------------------------------------

-- Aplicar aumento percentual
CREATE OR REPLACE FUNCTION aplicar_aumento(
    INOUT valor DECIMAL,
    percentual DECIMAL
)
LANGUAGE plpgsql
AS $$
BEGIN
    valor := valor * (1 + percentual/100);
END;
$$;

-- üí° INOUT ‚Üí valor entra, √© modificado e retorna

-- Uso:
SELECT aplicar_aumento(100.00, 10);  -- retorna 110.00

================================================================================
4. PROCEDIMENTOS ARMAZENADOS (PROCEDURES)
================================================================================

CONCEITO:
Diferente de fun√ß√µes, procedures:
- N√ÉO retornam valores (usam OUT se precisar)
- Podem fazer COMMIT/ROLLBACK
- √öteis para opera√ß√µes de modifica√ß√£o de dados

SINTAXE:
CREATE OR REPLACE PROCEDURE nome(parametros)
LANGUAGE plpgsql
AS $$
BEGIN
    -- c√≥digo
END;
$$;

--------------------------------------------------------------------------------
EXEMPLO 9: Procedure Simples
--------------------------------------------------------------------------------

-- Procedure para atualizar estoque
CREATE OR REPLACE PROCEDURE atualizar_estoque(
    p_produto_id INTEGER,
    p_quantidade INTEGER
)
LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE produtos
    SET estoque = estoque + p_quantidade,
        data_atualizacao = CURRENT_TIMESTAMP
    WHERE id = p_produto_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Produto % n√£o encontrado', p_produto_id;
    END IF;
    
    RAISE NOTICE 'Estoque atualizado com sucesso';
END;
$$;

-- üí° CALL ‚Üí executa procedure (diferente de SELECT para fun√ß√µes)
-- üí° IF NOT FOUND ‚Üí verifica se UPDATE afetou alguma linha

-- Uso:
CALL atualizar_estoque(10, 50);  -- adiciona 50 unidades

--------------------------------------------------------------------------------
EXEMPLO 10: Procedure com Transa√ß√£o
--------------------------------------------------------------------------------

-- Processar pedido completo
CREATE OR REPLACE PROCEDURE processar_pedido(
    p_pedido_id INTEGER
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_item RECORD;
BEGIN
    -- Atualizar status do pedido
    UPDATE pedidos
    SET status = 'PROCESSANDO'
    WHERE id = p_pedido_id;
    
    -- Dar baixa no estoque de cada item
    FOR v_item IN 
        SELECT produto_id, quantidade 
        FROM itens_pedido 
        WHERE pedido_id = p_pedido_id
    LOOP
        UPDATE produtos
        SET estoque = estoque - v_item.quantidade
        WHERE id = v_item.produto_id;
        
        -- Verificar se h√° estoque
        IF (SELECT estoque FROM produtos WHERE id = v_item.produto_id) < 0 THEN
            RAISE EXCEPTION 'Estoque insuficiente para produto %', v_item.produto_id;
        END IF;
    END LOOP;
    
    -- Confirmar pedido
    UPDATE pedidos
    SET status = 'CONFIRMADO'
    WHERE id = p_pedido_id;
    
    RAISE NOTICE 'Pedido % processado com sucesso', p_pedido_id;
    
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'Erro ao processar pedido: %', SQLERRM;
        RAISE;
END;
$$;

-- üí° FOR ... LOOP ‚Üí itera sobre resultados de SELECT
-- üí° RECORD ‚Üí tipo que armazena linha completa
-- üí° SQLERRM ‚Üí mensagem do erro

-- Uso:
CALL processar_pedido(15);

================================================================================
5. FUN√á√ïES √öTEIS DO SISTEMA
================================================================================

-- Listar todas as fun√ß√µes criadas:
SELECT 
    routine_name AS funcao,
    routine_type AS tipo
FROM information_schema.routines
WHERE routine_schema = 'public'
ORDER BY routine_name;

-- Ver c√≥digo de uma fun√ß√£o:
SELECT prosrc 
FROM pg_proc 
WHERE proname = 'nome_da_funcao';

-- Apagar fun√ß√£o:
DROP FUNCTION IF EXISTS nome_funcao;

-- Apagar procedure:
DROP PROCEDURE IF EXISTS nome_procedure;

================================================================================
EXERC√çCIOS PR√ÅTICOS
================================================================================

EXERC√çCIO 1: Fun√ß√£o de Valida√ß√£o [M√âDIO - 20 min]
Criar fun√ß√£o que valida CPF (aceita apenas formato XXX.XXX.XXX-XX).
Retornar TRUE se v√°lido, FALSE caso contr√°rio.

DICA: Use express√µes regulares ou verifica√ß√£o de tamanho.

--------------------------------------------------------------------------------

EXERC√çCIO 2: Fun√ß√£o de Relat√≥rio [M√âDIO - 25 min]
Criar fun√ß√£o que retorna produtos mais vendidos em um per√≠odo.
Par√¢metros: data_inicio, data_fim, limite
Retornar: nome_produto, quantidade_vendida, receita

--------------------------------------------------------------------------------

EXERC√çCIO 3: Procedure de Manuten√ß√£o [AVAN√áADO - 30 min]
Criar procedure que:
1. Desativa produtos sem estoque
2. Remove avalia√ß√µes antigas (mais de 2 anos)
3. Atualiza estat√≠sticas de vendas
4. Registra log das opera√ß√µes em tabela de auditoria

--------------------------------------------------------------------------------

EXERC√çCIO 4: Fun√ß√£o Recursiva [AVAN√áADO - 35 min]
Criar fun√ß√£o que calcula desconto em cadeia:
- Se cliente tem mais de 10 pedidos: 10%
- Se pedido > R$ 500: +5%
- Se cliente indicou 3+ amigos: +3%
- Desconto m√°ximo: 20%

Retornar desconto final aplic√°vel.

================================================================================
BOAS PR√ÅTICAS
================================================================================

‚úì Use nomes descritivos para fun√ß√µes
‚úì Comente o prop√≥sito de cada fun√ß√£o
‚úì Trate exce√ß√µes adequadamente
‚úì Valide par√¢metros de entrada
‚úì Use transa√ß√µes quando necess√°rio
‚úì Prefixe vari√°veis (v_, p_) para evitar conflitos
‚úì Teste fun√ß√µes isoladamente antes de usar em produ√ß√£o
‚úì Documente par√¢metros e valores de retorno

TAREFA: Criar 5 fun√ß√µes √∫teis para seu projeto | PR√ìXIMA AULA: Triggers

================================================================================
FIM DA AULA 11
================================================================================
