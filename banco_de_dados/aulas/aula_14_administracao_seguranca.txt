================================================================================
                              AULA 14 - DIA 14
                  ADMINISTRA√á√ÉO, BACKUP, SEGURAN√áA E USU√ÅRIOS
================================================================================

HOR√ÅRIO: 13:30 - 17:30 | DATA: _____/_____/_____

OBJETIVOS:
‚úì Gerenciar usu√°rios e permiss√µes
‚úì Implementar seguran√ßa de dados
‚úì Realizar backup e restore
‚úì Monitorar banco de dados
‚úì Manuten√ß√£o preventiva

CRONOGRAMA:
13:30-14:30 ‚Üí Usu√°rios e Permiss√µes
14:30-15:30 ‚Üí Seguran√ßa
15:30-15:45 ‚Üí Intervalo
15:45-16:30 ‚Üí Backup e Restore
16:30-17:30 ‚Üí Monitoramento e Manuten√ß√£o

================================================================================
1. GERENCIAMENTO DE USU√ÅRIOS
================================================================================

CONCEITO:
No PostgreSQL, usu√°rios s√£o chamados de ROLES.
Roles podem ter permiss√µes (LOGIN, CREATEDB, etc.)

--------------------------------------------------------------------------------
CRIAR USU√ÅRIOS
--------------------------------------------------------------------------------

-- Criar role sem login (grupo)
CREATE ROLE vendas;

-- Criar usu√°rio com login
CREATE ROLE joao WITH LOGIN PASSWORD 'senha123';

-- Criar usu√°rio com op√ß√µes
CREATE ROLE maria WITH 
    LOGIN 
    PASSWORD 'senha456'
    CREATEDB           -- pode criar databases
    VALID UNTIL '2025-12-31';

-- Criar superusu√°rio (cuidado!)
CREATE ROLE admin WITH LOGIN PASSWORD 'admin123' SUPERUSER;

üí° PASSWORD ‚Üí senha criptografada
üí° VALID UNTIL ‚Üí expira√ß√£o da conta
üí° SUPERUSER ‚Üí acesso total (perigoso)

--------------------------------------------------------------------------------
MODIFICAR USU√ÅRIOS
--------------------------------------------------------------------------------

-- Alterar senha
ALTER ROLE joao WITH PASSWORD 'novasenha';

-- Remover permiss√£o
ALTER ROLE maria WITH NOCREATEDB;

-- Renomear
ALTER ROLE joao RENAME TO joao_silva;

-- Deletar usu√°rio
DROP ROLE IF EXISTS maria;

üí° N√£o pode deletar role que possui objetos

--------------------------------------------------------------------------------
LISTAR USU√ÅRIOS
--------------------------------------------------------------------------------

-- Via SQL:
SELECT 
    rolname AS usuario,
    rolsuper AS superuser,
    rolcreatedb AS pode_criar_db,
    rolcanlogin AS pode_logar
FROM pg_roles
WHERE rolname NOT LIKE 'pg_%'
ORDER BY rolname;

-- Via comando DBeaver:
\du

================================================================================
2. PERMISS√ïES (GRANT/REVOKE)
================================================================================

N√çVEIS DE PERMISS√ÉO:
- DATABASE ‚Üí acesso ao banco
- SCHEMA ‚Üí acesso ao schema
- TABLE ‚Üí SELECT, INSERT, UPDATE, DELETE
- COLUMN ‚Üí permiss√µes espec√≠ficas por coluna
- FUNCTION ‚Üí EXECUTE

--------------------------------------------------------------------------------
GRANT - CONCEDER PERMISS√ïES
--------------------------------------------------------------------------------

-- Conectar ao banco
GRANT CONNECT ON DATABASE loja TO joao;

-- Usar schema
GRANT USAGE ON SCHEMA public TO joao;

-- Permiss√µes em tabela espec√≠fica
GRANT SELECT ON produtos TO joao;
GRANT SELECT, INSERT ON clientes TO maria;
GRANT ALL PRIVILEGES ON pedidos TO admin;

-- Permiss√µes em todas as tabelas do schema
GRANT SELECT ON ALL TABLES IN SCHEMA public TO joao;

-- Permiss√µes futuras (para tabelas que ainda ser√£o criadas)
ALTER DEFAULT PRIVILEGES IN SCHEMA public
GRANT SELECT ON TABLES TO joao;

üí° ALL PRIVILEGES ‚Üí SELECT, INSERT, UPDATE, DELETE
üí° DEFAULT PRIVILEGES ‚Üí aplica a objetos futuros

--------------------------------------------------------------------------------
GRANT por Coluna
--------------------------------------------------------------------------------

-- Permitir SELECT apenas em colunas espec√≠ficas
GRANT SELECT (id, nome, email) ON clientes TO vendedor;

-- Usu√°rio N√ÉO ver√° outras colunas (cpf, telefone, etc.)

--------------------------------------------------------------------------------
REVOKE - REMOVER PERMISS√ïES
--------------------------------------------------------------------------------

-- Remover permiss√£o espec√≠fica
REVOKE INSERT ON clientes FROM maria;

-- Remover todas permiss√µes
REVOKE ALL PRIVILEGES ON produtos FROM joao;

-- Remover de todas tabelas
REVOKE SELECT ON ALL TABLES IN SCHEMA public FROM joao;

--------------------------------------------------------------------------------
VERIFICAR PERMISS√ïES
--------------------------------------------------------------------------------

-- Permiss√µes de uma tabela
SELECT 
    grantee,
    privilege_type
FROM information_schema.table_privileges
WHERE table_name = 'produtos';

-- Ou via comando:
\dp produtos

================================================================================
3. ROLES E HIERARQUIA
================================================================================

CONCEITO:
Criar grupos de permiss√µes e atribuir a usu√°rios.

--------------------------------------------------------------------------------
EXEMPLO: Sistema de Vendas
--------------------------------------------------------------------------------

-- Criar roles de grupos
CREATE ROLE readonly;
CREATE ROLE vendedor;
CREATE ROLE gerente;

-- Definir permiss√µes dos grupos
GRANT CONNECT ON DATABASE loja TO readonly;
GRANT USAGE ON SCHEMA public TO readonly;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO readonly;

GRANT readonly TO vendedor;  -- vendedor herda de readonly
GRANT INSERT, UPDATE ON pedidos, itens_pedido TO vendedor;

GRANT vendedor TO gerente;   -- gerente herda de vendedor
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO gerente;

-- Criar usu√°rios e atribuir a grupos
CREATE ROLE carlos WITH LOGIN PASSWORD 'senha1';
GRANT readonly TO carlos;

CREATE ROLE ana WITH LOGIN PASSWORD 'senha2';
GRANT vendedor TO ana;

CREATE ROLE paulo WITH LOGIN PASSWORD 'senha3';
GRANT gerente TO paulo;

üí° Hierarquia: readonly < vendedor < gerente
üí° Facilita gerenciamento de permiss√µes

================================================================================
4. SEGURAN√áA DE DADOS
================================================================================

ROW LEVEL SECURITY (RLS)
--------------------------------------------------------------------------------

CONCEITO:
Controlar acesso por LINHA, n√£o apenas tabela.
Usu√°rio v√™ apenas registros que lhe pertencem.

-- Habilitar RLS na tabela
ALTER TABLE pedidos ENABLE ROW LEVEL SECURITY;

-- Criar pol√≠tica: usu√°rio v√™ apenas seus pedidos
CREATE POLICY ver_proprios_pedidos ON pedidos
    FOR SELECT
    USING (cliente_id = (
        SELECT id FROM clientes WHERE email = CURRENT_USER
    ));

-- Criar pol√≠tica: vendedor v√™ pedidos de sua regi√£o
CREATE POLICY ver_pedidos_regiao ON pedidos
    FOR SELECT
    TO vendedor
    USING (regiao = (
        SELECT regiao FROM vendedores WHERE usuario = CURRENT_USER
    ));

üí° USING ‚Üí condi√ß√£o que define linhas vis√≠veis
üí° TO vendedor ‚Üí aplica apenas a role vendedor

-- Verificar pol√≠ticas:
SELECT * FROM pg_policies WHERE tablename = 'pedidos';

--------------------------------------------------------------------------------
CRIPTOGRAFIA DE DADOS SENS√çVEIS
--------------------------------------------------------------------------------

-- Extens√£o pgcrypto para criptografia
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- Inserir dado criptografado
INSERT INTO clientes (nome, cpf_criptografado)
VALUES ('Jo√£o', crypt('12345678900', gen_salt('bf')));

-- Verificar dado criptografado
SELECT * FROM clientes
WHERE cpf_criptografado = crypt('12345678900', cpf_criptografado);

üí° 'bf' ‚Üí Blowfish, algoritmo seguro
üí° Senha nunca armazenada em texto puro

--------------------------------------------------------------------------------
AUDITORIA DE ACESSOS
--------------------------------------------------------------------------------

-- Tabela de log de acessos
CREATE TABLE log_acessos (
    id SERIAL PRIMARY KEY,
    usuario VARCHAR(100),
    acao VARCHAR(50),
    tabela VARCHAR(100),
    data_hora TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    ip_origem INET
);

-- Fun√ß√£o para logar
CREATE OR REPLACE FUNCTION registrar_acesso()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO log_acessos (usuario, acao, tabela, ip_origem)
    VALUES (
        CURRENT_USER,
        TG_OP,
        TG_TABLE_NAME,
        inet_client_addr()
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Aplicar em tabelas cr√≠ticas
CREATE TRIGGER trg_log_produtos
AFTER INSERT OR UPDATE OR DELETE ON produtos
FOR EACH ROW
EXECUTE FUNCTION registrar_acesso();

üí° inet_client_addr() ‚Üí IP do cliente
üí° CURRENT_USER ‚Üí usu√°rio conectado

================================================================================
5. BACKUP E RESTORE
================================================================================

TIPOS DE BACKUP:
1. L√≥gico (pg_dump) ‚Üí texto SQL ou arquivo custom
2. F√≠sico (pg_basebackup) ‚Üí c√≥pia dos arquivos do banco

--------------------------------------------------------------------------------
PG_DUMP - Backup L√≥gico
--------------------------------------------------------------------------------

No terminal (PowerShell):

# Backup de database inteiro (formato SQL)
pg_dump -U postgres -d loja -f backup_loja.sql

# Backup formato custom (compactado)
pg_dump -U postgres -d loja -F c -f backup_loja.backup

# Backup apenas estrutura (sem dados)
pg_dump -U postgres -d loja -s -f estrutura_loja.sql

# Backup apenas dados
pg_dump -U postgres -d loja -a -f dados_loja.sql

# Backup de tabela espec√≠fica
pg_dump -U postgres -d loja -t produtos -f backup_produtos.sql

# Backup com compress√£o gzip
pg_dump -U postgres -d loja | gzip > backup_loja.sql.gz

üí° -U ‚Üí usu√°rio
üí° -d ‚Üí database
üí° -f ‚Üí arquivo de sa√≠da
üí° -F c ‚Üí formato custom (menor e mais r√°pido para restore)
üí° -s ‚Üí schema only
üí° -a ‚Üí data only
üí° -t ‚Üí tabela espec√≠fica

--------------------------------------------------------------------------------
PG_RESTORE - Restaurar Backup
--------------------------------------------------------------------------------

# Criar database vazio
createdb -U postgres loja_restaurada

# Restaurar backup custom
pg_restore -U postgres -d loja_restaurada -v backup_loja.backup

# Restaurar backup SQL
psql -U postgres -d loja_restaurada -f backup_loja.sql

# Restaurar apenas estrutura
pg_restore -U postgres -d loja_restaurada -s backup_loja.backup

# Restaurar apenas dados
pg_restore -U postgres -d loja_restaurada -a backup_loja.backup

# Restaurar tabela espec√≠fica
pg_restore -U postgres -d loja_restaurada -t produtos backup_loja.backup

üí° -v ‚Üí verbose (mostra progresso)
üí° Sempre criar database vazio antes

--------------------------------------------------------------------------------
BACKUP AUTOMATIZADO (Script PowerShell)
--------------------------------------------------------------------------------

# Criar arquivo: backup_automatico.ps1
$data = Get-Date -Format "yyyyMMdd_HHmmss"
$arquivo = "D:\backups\loja_$data.backup"

pg_dump -U postgres -d loja -F c -f $arquivo

# Manter apenas √∫ltimos 7 dias
Get-ChildItem "D:\backups\loja_*.backup" | 
    Where-Object {$_.LastWriteTime -lt (Get-Date).AddDays(-7)} | 
    Remove-Item

üí° Agendar no Windows Task Scheduler
üí° Rodar diariamente √†s 2h da manh√£

================================================================================
6. MONITORAMENTO
================================================================================

CONSULTAS √öTEIS
--------------------------------------------------------------------------------

-- Tamanho das databases
SELECT 
    datname AS database,
    pg_size_pretty(pg_database_size(datname)) AS tamanho
FROM pg_database
WHERE datname NOT LIKE 'template%'
ORDER BY pg_database_size(datname) DESC;

-- Tamanho das tabelas
SELECT 
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS tamanho
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;

-- Conex√µes ativas
SELECT 
    pid,
    usename AS usuario,
    application_name AS aplicacao,
    client_addr AS ip,
    state AS estado,
    query
FROM pg_stat_activity
WHERE state = 'active';

-- Matar conex√£o espec√≠fica
SELECT pg_terminate_backend(pid) 
WHERE pid = 12345;

-- Queries mais lentas (top 10)
SELECT 
    query,
    calls,
    total_exec_time,
    mean_exec_time,
    max_exec_time
FROM pg_stat_statements
ORDER BY mean_exec_time DESC
LIMIT 10;

üí° pg_stat_statements ‚Üí extens√£o para estat√≠sticas de queries

-- Tabelas que precisam VACUUM
SELECT 
    schemaname,
    tablename,
    n_dead_tup AS linhas_mortas,
    last_vacuum,
    last_autovacuum
FROM pg_stat_user_tables
WHERE n_dead_tup > 1000
ORDER BY n_dead_tup DESC;

================================================================================
7. MANUTEN√á√ÉO
================================================================================

-- VACUUM: Limpar espa√ßo de linhas deletadas
VACUUM produtos;
VACUUM;  -- todas as tabelas

-- VACUUM FULL: Recuperar espa√ßo no disco (bloqueia tabela)
VACUUM FULL produtos;

-- ANALYZE: Atualizar estat√≠sticas para otimizador
ANALYZE produtos;
ANALYZE;  -- todas as tabelas

-- VACUUM ANALYZE: Ambos
VACUUM ANALYZE;

-- REINDEX: Reconstruir √≠ndices
REINDEX TABLE produtos;
REINDEX INDEX idx_produtos_nome;
REINDEX DATABASE loja;  -- todos os √≠ndices

-- Verificar necessidade de VACUUM
SELECT 
    schemaname,
    tablename,
    n_tup_ins AS inseridas,
    n_tup_upd AS atualizadas,
    n_tup_del AS deletadas,
    n_dead_tup AS mortas
FROM pg_stat_user_tables
ORDER BY n_dead_tup DESC;

üí° AutoVACUUM roda automaticamente, mas VACUUM manual pode ser necess√°rio

================================================================================
EXERC√çCIOS PR√ÅTICOS
================================================================================

EXERC√çCIO 1: Gerenciamento de Usu√°rios [M√âDIO - 25 min]
Criar estrutura de usu√°rios:
- Role readonly (apenas consulta)
- Role vendedor (consulta + inserir pedidos)
- Role gerente (tudo exceto DELETE)
- Role admin (acesso total)
Criar 2 usu√°rios em cada grupo

--------------------------------------------------------------------------------

EXERC√çCIO 2: Row Level Security [AVAN√áADO - 30 min]
Implementar RLS onde:
- Vendedores veem apenas pedidos de seus clientes
- Gerentes veem pedidos de sua filial
- Admin v√™ tudo

--------------------------------------------------------------------------------

EXERC√çCIO 3: Backup Completo [M√âDIO - 25 min]
1. Fazer backup do database
2. Criar novo database
3. Restaurar backup
4. Verificar integridade

--------------------------------------------------------------------------------

EXERC√çCIO 4: Script de Monitoramento [AVAN√áADO - 35 min]
Criar query que gera relat√≥rio:
- Tamanho de cada tabela
- √çndices n√£o usados
- Tabelas que precisam VACUUM
- Conex√µes ativas
- Top 5 queries mais lentas

================================================================================
CHECKLIST DE SEGURAN√áA
================================================================================

‚ñ° Nunca usar superusu√°rio em aplica√ß√µes
‚ñ° Usar roles com privil√©gios m√≠nimos
‚ñ° Senhas fortes e expira√ß√£o
‚ñ° Criptografar dados sens√≠veis
‚ñ° Implementar RLS onde apropriado
‚ñ° Auditar opera√ß√µes cr√≠ticas
‚ñ° Backup di√°rio automatizado
‚ñ° Testar restore regularmente
‚ñ° Monitorar conex√µes e queries
‚ñ° VACUUM e ANALYZE peri√≥dicos
‚ñ° Atualizar PostgreSQL regularmente
‚ñ° Documentar permiss√µes

TAREFA: Implementar seguran√ßa e backup | PR√ìXIMA AULA: PROJETO FINAL!

================================================================================
FIM DA AULA 14
================================================================================
