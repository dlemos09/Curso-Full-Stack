================================================================================
                              AULA 09 - DIA 9
                  VIEWS, MATERIALIZED VIEWS E √çNDICES
================================================================================

HOR√ÅRIO: 13:30 - 17:30 | DATA: _____/_____/_____

OBJETIVOS:
‚úì Criar e gerenciar VIEWs
‚úì Usar MATERIALIZED VIEWs para performance
‚úì Entender tipos de √≠ndices (B-Tree, GIN, GIST)
‚úì Criar √≠ndices estrat√©gicos
‚úì Analisar performance com EXPLAIN

CRONOGRAMA:
13:30-13:45 ‚Üí Revis√£o | 13:45-14:45 ‚Üí Views
14:45-15:30 ‚Üí Materialized Views | 15:30-15:45 ‚Üí Intervalo
15:45-17:00 ‚Üí √çndices e Performance | 17:00-17:30 ‚Üí Exerc√≠cios

================================================================================
PARTE 1: VIEWS
================================================================================

-- VIEW: query salva como "tabela virtual"

CREATE VIEW vw_funcionarios_completo AS
SELECT 
    f.id,
    f.nome,
    f.salario,
    d.nome AS departamento,
    c.titulo AS cargo
FROM funcionarios f
LEFT JOIN departamentos d ON f.departamento_id = d.id
LEFT JOIN cargos c ON f.cargo_id = c.id;

-- Usar a view:
SELECT * FROM vw_funcionarios_completo WHERE salario > 5000;

/*
üí° VANTAGENS DAS VIEWS:
   - Simplificam queries complexas
   - Seguran√ßa (ocultar colunas sens√≠veis)
   - Padroniza√ß√£o (todos usam mesma l√≥gica)
   - Manuten√ß√£o (alterar view altera para todos)
*/

-- Alterar view:
CREATE OR REPLACE VIEW vw_funcionarios_completo AS
SELECT 
    f.id,
    f.nome,
    f.salario,
    f.email,  -- Nova coluna
    d.nome AS departamento
FROM funcionarios f
LEFT JOIN departamentos d ON f.departamento_id = d.id;

-- Remover view:
DROP VIEW vw_funcionarios_completo;

-- View com par√¢metros (usando WHERE):
CREATE VIEW vw_produtos_ativos AS
SELECT * FROM produtos WHERE ativo = TRUE;

SELECT * FROM vw_produtos_ativos WHERE preco > 100;

================================================================================
PARTE 2: MATERIALIZED VIEWS
================================================================================

-- MATERIALIZED VIEW: armazena RESULTADO fisicamente

CREATE MATERIALIZED VIEW mv_vendas_categoria AS
SELECT 
    c.nome AS categoria,
    COUNT(ip.id) AS total_itens,
    SUM(ip.quantidade * ip.preco_unitario) AS receita
FROM categorias c
LEFT JOIN produtos p ON c.id = p.categoria_id
LEFT JOIN itens_pedido ip ON p.id = ip.produto_id
GROUP BY c.id, c.nome;

-- Consultar (muito r√°pido, dados j√° calculados):
SELECT * FROM mv_vendas_categoria ORDER BY receita DESC;

-- Atualizar dados:
REFRESH MATERIALIZED VIEW mv_vendas_categoria;

/*
üìä VIEW vs MATERIALIZED VIEW:

VIEW:
   - Executa query toda vez
   - Sempre dados atualizados
   - Lenta se query for complexa

MATERIALIZED VIEW:
   - Armazena resultado (snapshot)
   - Muito r√°pida para consultar
   - Precisa REFRESH para atualizar
   - Usa espa√ßo em disco
*/

-- REFRESH em background (n√£o bloqueia):
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_vendas_categoria;
-- Requer √≠ndice UNIQUE

-- Criar √≠ndice na materialized view:
CREATE UNIQUE INDEX idx_mv_vendas_cat ON mv_vendas_categoria(categoria);

-- Remover:
DROP MATERIALIZED VIEW mv_vendas_categoria;

================================================================================
PARTE 3: √çNDICES
================================================================================

-- √çNDICE: estrutura para acelerar buscas

-- √çndice simples (B-Tree - padr√£o):
CREATE INDEX idx_produtos_nome ON produtos(nome);

-- Agora buscas por nome s√£o MUITO mais r√°pidas:
SELECT * FROM produtos WHERE nome = 'Notebook';

-- √çndice composto (m√∫ltiplas colunas):
CREATE INDEX idx_pedidos_cliente_data 
ON pedidos(cliente_id, data_pedido);

-- Otimiza queries como:
SELECT * FROM pedidos 
WHERE cliente_id = 10 AND data_pedido > '2024-01-01';

-- √çndice UNIQUE (tamb√©m acelera + garante unicidade):
CREATE UNIQUE INDEX idx_funcionarios_cpf ON funcionarios(cpf);

-- √çndice parcial (apenas parte dos dados):
CREATE INDEX idx_produtos_ativos_preco 
ON produtos(preco) 
WHERE ativo = TRUE;
-- Indexa apenas produtos ativos (economiza espa√ßo)

/*
‚ö†Ô∏è QUANDO CRIAR √çNDICES:
   ‚úì Colunas usadas em WHERE frequentemente
   ‚úì Colunas usadas em JOIN
   ‚úì Colunas usadas em ORDER BY
   ‚úó Tabelas pequenas (< 1000 linhas)
   ‚úó Colunas que mudam muito (INSERT/UPDATE fica lento)
*/

-- Remover √≠ndice:
DROP INDEX idx_produtos_nome;

-- Listar √≠ndices de uma tabela:
SELECT indexname, indexdef 
FROM pg_indexes 
WHERE tablename = 'produtos';

================================================================================
PARTE 4: TIPOS DE √çNDICES
================================================================================

-- B-TREE (padr√£o) - melhor para:
-- =, <, >, <=, >=, BETWEEN, IN, ORDER BY
CREATE INDEX idx_produtos_preco ON produtos(preco);

-- GIN (Generalized Inverted Index) - melhor para:
-- Arrays, JSONB, full-text search
CREATE INDEX idx_documentos_tags ON documentos USING GIN(tags);
-- tags √© um array

-- GIST (Generalized Search Tree) - melhor para:
-- Dados geom√©tricos, busca de texto
CREATE INDEX idx_locais_geometria ON locais USING GIST(geometria);

-- HASH - apenas para =
CREATE INDEX idx_usuarios_email ON usuarios USING HASH(email);

================================================================================
PARTE 5: EXPLAIN - ANALISAR PERFORMANCE
================================================================================

-- EXPLAIN: mostra plano de execu√ß√£o

EXPLAIN SELECT * FROM produtos WHERE preco > 100;

-- Resultado mostra:
-- - Seq Scan = varredura completa (lento)
-- - Index Scan = usa √≠ndice (r√°pido)
-- - cost = estimativa de custo

-- EXPLAIN ANALYZE: executa E analisa
EXPLAIN ANALYZE SELECT * FROM produtos WHERE nome LIKE '%Notebook%';

-- Mostra tempo real de execu√ß√£o

/*
üìä INTERPRETAR EXPLAIN:

Seq Scan ‚Üí Varredura completa (SEM √≠ndice)
   - L√™ toda a tabela
   - Lento para tabelas grandes

Index Scan ‚Üí Usa √≠ndice
   - Muito mais r√°pido
   - Ideal para buscas espec√≠ficas

Bitmap Index Scan ‚Üí Combina m√∫ltiplos √≠ndices
   - Usa v√°rios √≠ndices juntos

Cost: 0.00..100.50
   - Primeiro n√∫mero: custo inicial
   - Segundo: custo total estimado
   - Menor = melhor
*/

-- Exemplo comparando com/sem √≠ndice:

-- SEM √≠ndice:
EXPLAIN ANALYZE SELECT * FROM produtos WHERE categoria_id = 5;
-- Seq Scan | cost=0.00..50.00 | tempo=15ms

-- Criar √≠ndice:
CREATE INDEX idx_produtos_categoria ON produtos(categoria_id);

-- COM √≠ndice:
EXPLAIN ANALYZE SELECT * FROM produtos WHERE categoria_id = 5;
-- Index Scan | cost=0.00..8.50 | tempo=2ms

================================================================================
EXERC√çCIOS PR√ÅTICOS
================================================================================

üí™ EXERC√çCIO 1: Views (10 min)
Crie views para:
a) Produtos com estoque baixo (< m√≠nimo)
b) Funcion√°rios com dados completos (join com depto e cargo)
c) Pedidos do m√™s atual com dados do cliente

üí™ EXERC√çCIO 2: Materialized Views (10 min)
a) Criar MV com vendas por dia do √∫ltimo ano
b) MV com ranking de produtos mais vendidos
c) REFRESH as MVs criadas

üí™ EXERC√çCIO 3: √çndices (15 min)
a) Criar √≠ndices em colunas usadas em WHERE
b) √çndice composto para (cliente_id, data_pedido)
c) √çndice parcial em produtos ativos
d) Comparar performance com EXPLAIN antes/depois

üí™ DESAFIO:
Otimizar query lenta:
- Identifique gargalos com EXPLAIN
- Crie √≠ndices apropriados
- Me√ßa melhoria de performance

RESUMO:
‚Ä¢ VIEW ‚Üí query virtual, sempre atualizada
‚Ä¢ MATERIALIZED VIEW ‚Üí snapshot f√≠sico, precisa REFRESH
‚Ä¢ √çndices aceleram buscas (WHERE, JOIN, ORDER BY)
‚Ä¢ B-Tree (padr√£o), GIN (arrays/JSON), GIST (geo), HASH
‚Ä¢ EXPLAIN mostra plano de execu√ß√£o
‚Ä¢ EXPLAIN ANALYZE executa e mede tempo real

TAREFA: Estudar para Projeto 1 | PR√ìXIMA AULA: Projeto Pr√°tico Integrado

================================================================================
FIM DA AULA 09
================================================================================
