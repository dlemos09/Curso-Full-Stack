================================================================================
                              AULA 13 - DIA 13
                    OTIMIZA√á√ÉO DE PERFORMANCE E EXPLAIN ANALYZE
================================================================================

HOR√ÅRIO: 13:30 - 17:30 | DATA: _____/_____/_____

OBJETIVOS:
‚úì Identificar gargalos de performance
‚úì Interpretar planos de execu√ß√£o (EXPLAIN)
‚úì Otimizar queries lentas
‚úì Criar √≠ndices eficientes
‚úì T√©cnicas de tuning

CRONOGRAMA:
13:30-14:30 ‚Üí EXPLAIN e EXPLAIN ANALYZE
14:30-15:30 ‚Üí Otimiza√ß√£o de Queries
15:30-15:45 ‚Üí Intervalo
15:45-16:30 ‚Üí √çndices Avan√ßados
16:30-17:30 ‚Üí Pr√°tica e Tuning

================================================================================
1. EXPLAIN - ENTENDENDO PLANOS DE EXECU√á√ÉO
================================================================================

CONCEITO:
EXPLAIN mostra como o PostgreSQL executa uma query.
Essencial para identificar problemas de performance.

COMANDOS:
- EXPLAIN ‚Üí mostra plano sem executar
- EXPLAIN ANALYZE ‚Üí executa e mostra estat√≠sticas reais
- EXPLAIN (ANALYZE, BUFFERS) ‚Üí incluir uso de mem√≥ria

--------------------------------------------------------------------------------
EXEMPLO 1: EXPLAIN B√°sico
--------------------------------------------------------------------------------

EXPLAIN
SELECT * FROM produtos WHERE categoria_id = 5;

RESULTADO:
Seq Scan on produtos  (cost=0.00..15.50 rows=10 width=100)
  Filter: (categoria_id = 5)

üí° Seq Scan ‚Üí varredura sequencial (l√™ tabela inteira)
üí° cost=0.00..15.50 ‚Üí custo estimado (inicial..final)
üí° rows=10 ‚Üí linhas estimadas
üí° width=100 ‚Üí tamanho m√©dio da linha em bytes

--------------------------------------------------------------------------------
EXEMPLO 2: EXPLAIN ANALYZE (Com Execu√ß√£o Real)
--------------------------------------------------------------------------------

EXPLAIN ANALYZE
SELECT p.nome, c.nome AS categoria
FROM produtos p
INNER JOIN categorias c ON p.categoria_id = c.id
WHERE p.preco > 100;

RESULTADO:
Hash Join  (cost=1.15..18.45 rows=5 width=64) 
           (actual time=0.025..0.042 rows=8 loops=1)
  Hash Cond: (p.categoria_id = c.id)
  ->  Seq Scan on produtos p  (cost=0.00..15.50 rows=5 width=100)
                               (actual time=0.010..0.015 rows=8 loops=1)
        Filter: (preco > 100::numeric)
  ->  Hash  (cost=1.05..1.05 rows=5 width=64)
            (actual time=0.008..0.008 rows=5 loops=1)
        ->  Seq Scan on categorias c  (cost=0.00..1.05 rows=5 width=64)
Planning Time: 0.125 ms
Execution Time: 0.068 ms

üí° actual time ‚Üí tempo real de execu√ß√£o
üí° rows=8 ‚Üí linhas realmente retornadas
üí° loops=1 ‚Üí quantas vezes o n√≥ foi executado
üí° Planning Time ‚Üí tempo de planejamento
üí° Execution Time ‚Üí tempo de execu√ß√£o

================================================================================
2. TIPOS DE SCAN
================================================================================

1. SEQ SCAN (Sequential Scan)
   - L√™ tabela inteira linha por linha
   - LENTO para tabelas grandes
   - OK para tabelas pequenas ou quando busca muitos registros

2. INDEX SCAN
   - Usa √≠ndice para localizar registros
   - R√ÅPIDO para poucos registros
   - Melhor quando filtra pequena porcentagem

3. INDEX ONLY SCAN
   - Dados v√™m APENAS do √≠ndice (n√£o acessa tabela)
   - MUITO R√ÅPIDO

4. BITMAP SCAN
   - Cria bitmap de p√°ginas a visitar
   - Bom para m√∫ltiplos √≠ndices ou muitos resultados

--------------------------------------------------------------------------------
EXEMPLO 3: Compara√ß√£o Com e Sem √çndice
--------------------------------------------------------------------------------

-- SEM √≠ndice:
EXPLAIN ANALYZE
SELECT * FROM produtos WHERE nome = 'Notebook Dell';

Seq Scan on produtos  (cost=0.00..20.00 rows=1 width=100)
                      (actual time=0.050..0.250 rows=1 loops=1)
  Filter: (nome = 'Notebook Dell'::text)
  Rows Removed by Filter: 999
Execution Time: 0.275 ms

-- Criar √≠ndice:
CREATE INDEX idx_produtos_nome ON produtos(nome);

-- COM √≠ndice:
EXPLAIN ANALYZE
SELECT * FROM produtos WHERE nome = 'Notebook Dell';

Index Scan using idx_produtos_nome on produtos
    (cost=0.28..8.29 rows=1 width=100)
    (actual time=0.015..0.016 rows=1 loops=1)
  Index Cond: (nome = 'Notebook Dell'::text)
Execution Time: 0.035 ms

üí° Execution Time: 0.275ms ‚Üí 0.035ms (8x mais r√°pido!)
üí° Index Scan vs Seq Scan

================================================================================
3. OTIMIZA√á√ÉO DE QUERIES
================================================================================

PROBLEMA 1: SELECT *
--------------------------------------------------------------------------------

‚ùå RUIM:
SELECT * FROM produtos WHERE ativo = TRUE;

‚úÖ BOM:
SELECT id, nome, preco FROM produtos WHERE ativo = TRUE;

üí° Selecione apenas colunas necess√°rias
üí° Reduz transfer√™ncia de dados
üí° Possibilita Index Only Scan

--------------------------------------------------------------------------------

PROBLEMA 2: Fun√ß√µes em WHERE
--------------------------------------------------------------------------------

‚ùå RUIM (n√£o usa √≠ndice):
SELECT * FROM clientes WHERE LOWER(email) = 'joao@email.com';

‚úÖ BOM:
-- Op√ß√£o 1: Normalizar dados (trigger)
SELECT * FROM clientes WHERE email = 'joao@email.com';

-- Op√ß√£o 2: √çndice funcional
CREATE INDEX idx_clientes_email_lower ON clientes(LOWER(email));
SELECT * FROM clientes WHERE LOWER(email) = 'joao@email.com';

üí° Fun√ß√µes em colunas impedem uso de √≠ndice
üí° √çndices funcionais resolvem isso

--------------------------------------------------------------------------------

PROBLEMA 3: OR vs UNION
--------------------------------------------------------------------------------

‚ùå LENTO:
SELECT * FROM produtos 
WHERE categoria_id = 1 OR categoria_id = 2;

‚úÖ R√ÅPIDO:
SELECT * FROM produtos WHERE categoria_id IN (1, 2);

-- Ou ainda melhor com UNION (se √≠ndices diferentes):
SELECT * FROM produtos WHERE categoria_id = 1
UNION ALL
SELECT * FROM produtos WHERE categoria_id = 2;

üí° IN geralmente √© otimizado
üí° UNION ALL pode usar √≠ndices separadamente

--------------------------------------------------------------------------------

PROBLEMA 4: Subconsultas vs JOIN
--------------------------------------------------------------------------------

‚ùå PODE SER LENTO:
SELECT * FROM produtos
WHERE categoria_id IN (
    SELECT id FROM categorias WHERE ativo = TRUE
);

‚úÖ GERALMENTE MAIS R√ÅPIDO:
SELECT p.* 
FROM produtos p
INNER JOIN categorias c ON p.categoria_id = c.id
WHERE c.ativo = TRUE;

üí° JOIN geralmente mais eficiente
üí°ependendo do caso, EXISTS pode ser melhor

--------------------------------------------------------------------------------

PROBLEMA 5: LIMIT sem ORDER BY
--------------------------------------------------------------------------------

‚ùå IMPREVIS√çVEL:
SELECT * FROM produtos LIMIT 10;

‚úÖ PREVIS√çVEL E R√ÅPIDO:
CREATE INDEX idx_produtos_id ON produtos(id);
SELECT * FROM produtos ORDER BY id LIMIT 10;

üí° ORDER BY + √≠ndice + LIMIT = muito eficiente
üí° PostgreSQL pode parar ap√≥s encontrar N registros

================================================================================
4. √çNDICES AVAN√áADOS
================================================================================

√çNDICE PARCIAL
--------------------------------------------------------------------------------

-- √çndice apenas para produtos ativos
CREATE INDEX idx_produtos_ativos 
ON produtos(categoria_id) 
WHERE ativo = TRUE;

üí° Menor e mais r√°pido
üí° Usa menos espa√ßo
üí° Ideal quando query sempre filtra condi√ß√£o

-- Uso:
SELECT * FROM produtos 
WHERE categoria_id = 5 AND ativo = TRUE;  -- USA √≠ndice

SELECT * FROM produtos 
WHERE categoria_id = 5;  -- N√ÉO usa √≠ndice

--------------------------------------------------------------------------------

√çNDICE COMPOSTO (M√∫ltiplas Colunas)
--------------------------------------------------------------------------------

-- Ordem importa!
CREATE INDEX idx_produtos_cat_preco 
ON produtos(categoria_id, preco);

-- ‚úÖ USA √≠ndice:
SELECT * FROM produtos WHERE categoria_id = 5;
SELECT * FROM produtos WHERE categoria_id = 5 AND preco > 100;

-- ‚ùå N√ÉO usa √≠ndice completo:
SELECT * FROM produtos WHERE preco > 100;

üí° √çndice pode ser usado pela primeira coluna sozinha
üí° Coloque coluna mais seletiva primeiro (geralmente)

--------------------------------------------------------------------------------

√çNDICE COVERING (Inclui Colunas Extras)
--------------------------------------------------------------------------------

-- Incluir colunas adicionais
CREATE INDEX idx_produtos_cat_include 
ON produtos(categoria_id) 
INCLUDE (nome, preco);

-- Permite Index Only Scan:
SELECT nome, preco FROM produtos WHERE categoria_id = 5;

üí° INCLUDE ‚Üí colunas no √≠ndice mas n√£o na chave
üí° Ideal para queries que retornam poucas colunas

================================================================================
5. AN√ÅLISE DE PERFORMANCE REAL
================================================================================

EXEMPLO COMPLETO: Otimizar Query Lenta
--------------------------------------------------------------------------------

-- Query problem√°tica:
EXPLAIN ANALYZE
SELECT 
    c.nome AS cliente,
    COUNT(p.id) AS total_pedidos,
    SUM(p.valor_total) AS total_gasto
FROM clientes c
LEFT JOIN pedidos p ON c.id = p.cliente_id
WHERE c.ativo = TRUE
AND p.data_pedido >= CURRENT_DATE - INTERVAL '1 year'
GROUP BY c.id, c.nome
ORDER BY total_gasto DESC;

-- Resultado (antes):
Hash Right Join  (cost=50.00..250.00 rows=100 width=64)
    (actual time=15.250..45.500 rows=85 loops=1)
  ->  Seq Scan on pedidos p  (cost=0.00..180.00 rows=500 width=12)
        Filter: (data_pedido >= (CURRENT_DATE - '1 year'::interval))
        Rows Removed by Filter: 8500
  ->  Hash  (cost=40.00..40.00 rows=800 width=64)
        ->  Seq Scan on clientes c  (cost=0.00..40.00 rows=800 width=64)
              Filter: ativo
Execution Time: 45.750 ms

AN√ÅLISE DOS PROBLEMAS:
1. Seq Scan em pedidos (8500 linhas removidas!)
2. Seq Scan em clientes
3. Sem √≠ndices

SOLU√á√ÉO:
-- √çndice para filtro de data:
CREATE INDEX idx_pedidos_data ON pedidos(data_pedido);

-- √çndice para JOIN:
CREATE INDEX idx_pedidos_cliente ON pedidos(cliente_id);

-- √çndice para filtro de ativo:
CREATE INDEX idx_clientes_ativo ON clientes(ativo) WHERE ativo = TRUE;

-- Resultado (depois):
Hash Right Join  (cost=8.50..25.00 rows=100 width=64)
    (actual time=1.125..2.250 rows=85 loops=1)
  ->  Index Scan using idx_pedidos_data on pedidos p
        (cost=0.28..15.00 rows=500 width=12)
        Index Cond: (data_pedido >= (CURRENT_DATE - '1 year'::interval))
  ->  Hash  (cost=5.00..5.00 rows=800 width=64)
        ->  Bitmap Heap Scan on clientes c
              (cost=2.00..5.00 rows=800 width=64)
              ->  Bitmap Index Scan on idx_clientes_ativo
Execution Time: 2.500 ms

üí° 45.75ms ‚Üí 2.5ms (18x mais r√°pido!)

================================================================================
6. DICAS DE TUNING
================================================================================

1. VACUUM e ANALYZE
   -- Limpa espa√ßo morto e atualiza estat√≠sticas
   VACUUM ANALYZE produtos;

2. Estat√≠sticas Atualizadas
   -- PostgreSQL usa estat√≠sticas para planejar
   ANALYZE;  -- todas as tabelas

3. Configura√ß√µes de Mem√≥ria
   -- work_mem: mem√≥ria para ordena√ß√£o/hash
   -- shared_buffers: cache de dados
   
   -- Aumentar temporariamente:
   SET work_mem = '50MB';
   
4. Verificar √çndices N√£o Usados
   SELECT 
       schemaname,
       tablename,
       indexname,
       idx_scan
   FROM pg_stat_user_indexes
   WHERE idx_scan = 0
   ORDER BY pg_relation_size(indexrelid) DESC;

5. Tamanho de √çndices
   SELECT
       tablename,
       indexname,
       pg_size_pretty(pg_relation_size(indexrelid)) AS tamanho
   FROM pg_stat_user_indexes
   ORDER BY pg_relation_size(indexrelid) DESC;

================================================================================
EXERC√çCIOS PR√ÅTICOS
================================================================================

EXERC√çCIO 1: An√°lise de Performance [M√âDIO - 25 min]
1. Criar query complexa com JOINs e agrega√ß√µes
2. Executar EXPLAIN ANALYZE
3. Identificar gargalos
4. Criar √≠ndices apropriados
5. Comparar performance antes/depois

--------------------------------------------------------------------------------

EXERC√çCIO 2: Otimiza√ß√£o de Query [M√âDIO - 30 min]
Otimizar query que lista pedidos com:
- Cliente, produtos, quantidades
- Filtro por per√≠odo
- Ordena√ß√£o por valor total
- Deve executar em menos de 10ms

--------------------------------------------------------------------------------

EXERC√çCIO 3: √çndices Estrat√©gicos [AVAN√áADO - 35 min]
Criar estrat√©gia completa de √≠ndices para e-commerce:
1. Identificar queries mais frequentes
2. Criar √≠ndices apropriados (simples, compostos, parciais)
3. Documentar escolhas
4. Medir impacto

--------------------------------------------------------------------------------

EXERC√çCIO 4: Tuning Completo [AVAN√áADO - 40 min]
Otimizar banco inteiro:
1. VACUUM ANALYZE todas tabelas
2. Identificar √≠ndices n√£o usados
3. Reescrever queries lentas
4. Criar relat√≥rio de performance

================================================================================
CHECKLIST DE OTIMIZA√á√ÉO
================================================================================

‚ñ° Selecionar apenas colunas necess√°rias
‚ñ° Usar √≠ndices em colunas de filtro e JOIN
‚ñ° Evitar fun√ß√µes em WHERE
‚ñ° Preferir JOIN a subconsultas complexas
‚ñ° Usar LIMIT quando apropriado
‚ñ° Normalizar dados para evitar fun√ß√µes
‚ñ° Criar √≠ndices compostos para queries frequentes
‚ñ° Usar √≠ndices parciais quando poss√≠vel
‚ñ° VACUUM ANALYZE regularmente
‚ñ° Monitorar √≠ndices n√£o usados
‚ñ° Testar com dados realistas
‚ñ° Medir antes e depois

TAREFA: Otimizar queries do seu projeto | PR√ìXIMA AULA: Administra√ß√£o

================================================================================
FIM DA AULA 13
================================================================================
