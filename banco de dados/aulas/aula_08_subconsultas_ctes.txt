================================================================================
                              AULA 08 - DIA 8
                      SUBCONSULTAS E CTEs (WITH)
================================================================================

HOR√ÅRIO: 13:30 - 17:30 | DATA: _____/_____/_____

OBJETIVOS:
‚úì Usar subconsultas em SELECT, FROM, WHERE
‚úì Trabalhar com EXISTS e IN
‚úì Criar CTEs (Common Table Expressions) com WITH
‚úì Usar CTEs recursivas

CRONOGRAMA:
13:30-13:45 ‚Üí Revis√£o | 13:45-14:45 ‚Üí Subconsultas b√°sicas
14:45-15:30 ‚Üí EXISTS e correlacionadas | 15:30-15:45 ‚Üí Intervalo
15:45-17:00 ‚Üí CTEs e recursivas | 17:00-17:30 ‚Üí Exerc√≠cios

================================================================================
PARTE 1: SUBCONSULTAS EM WHERE
================================================================================

-- Subconsulta retorna VALOR √öNICO:
SELECT * FROM produtos 
WHERE preco > (SELECT AVG(preco) FROM produtos);
-- Produtos acima da m√©dia de pre√ßo

-- Subconsulta com IN (m√∫ltiplos valores):
SELECT * FROM funcionarios
WHERE departamento_id IN (
    SELECT id FROM departamentos WHERE ativo = TRUE
);

-- NOT IN:
SELECT * FROM clientes
WHERE id NOT IN (
    SELECT DISTINCT cliente_id FROM pedidos
);
-- Clientes que nunca compraram

/*
‚ö†Ô∏è CUIDADO COM NULL EM NOT IN:
   Se subconsulta retornar NULL, NOT IN pode dar resultado inesperado!
   Use EXISTS quando poss√≠vel.
*/

================================================================================
PARTE 2: EXISTS E NOT EXISTS
================================================================================

-- EXISTS: verifica se subconsulta retorna alguma linha

-- Clientes que fizeram pelo menos um pedido:
SELECT c.nome
FROM clientes c
WHERE EXISTS (
    SELECT 1 FROM pedidos p 
    WHERE p.cliente_id = c.id
);

-- NOT EXISTS: clientes sem pedidos
SELECT c.nome
FROM clientes c
WHERE NOT EXISTS (
    SELECT 1 FROM pedidos p 
    WHERE p.cliente_id = c.id
);

/*
üí° EXISTS √© mais eficiente que IN/NOT IN:
   - Para de buscar assim que encontra uma linha
   - Melhor com grandes volumes de dados
   - N√£o tem problema com NULL
*/

================================================================================
PARTE 3: SUBCONSULTAS CORRELACIONADAS
================================================================================

-- Correlacionada: subconsulta usa valor da query externa

-- Funcion√°rios que ganham acima da m√©dia do SEU departamento:
SELECT nome, salario, departamento_id
FROM funcionarios f1
WHERE salario > (
    SELECT AVG(salario) 
    FROM funcionarios f2 
    WHERE f2.departamento_id = f1.departamento_id
);

-- Produtos com pre√ßo acima da m√©dia da SUA categoria:
SELECT nome, preco, categoria_id
FROM produtos p1
WHERE preco > (
    SELECT AVG(preco) 
    FROM produtos p2 
    WHERE p2.categoria_id = p1.categoria_id
);

================================================================================
PARTE 4: SUBCONSULTAS NO FROM (DERIVED TABLES)
================================================================================

-- Subconsulta cria "tabela tempor√°ria":

SELECT categoria, media_preco
FROM (
    SELECT 
        categoria_id AS categoria,
        AVG(preco) AS media_preco
    FROM produtos
    GROUP BY categoria_id
) AS sub
WHERE media_preco > 100;

-- √ötil para simplificar queries complexas:
SELECT 
    vendas_mes.mes,
    vendas_mes.total,
    vendas_mes.total / 30 AS media_dia
FROM (
    SELECT 
        EXTRACT(MONTH FROM data_pedido) AS mes,
        SUM(valor_total) AS total
    FROM pedidos
    GROUP BY EXTRACT(MONTH FROM data_pedido)
) AS vendas_mes;

================================================================================
PARTE 5: CTEs - COMMON TABLE EXPRESSIONS (WITH)
================================================================================

-- CTE: vers√£o mais leg√≠vel de subconsulta

WITH vendas_categoria AS (
    SELECT 
        categoria_id,
        SUM(quantidade) AS total_vendido
    FROM produtos p
    JOIN itens_pedido ip ON p.id = ip.produto_id
    GROUP BY categoria_id
)
SELECT * FROM vendas_categoria
WHERE total_vendido > 100;

-- M√∫ltiplas CTEs:
WITH 
    clientes_ativos AS (
        SELECT * FROM clientes WHERE ativo = TRUE
    ),
    pedidos_2024 AS (
        SELECT * FROM pedidos WHERE EXTRACT(YEAR FROM data_pedido) = 2024
    )
SELECT 
    c.nome,
    COUNT(p.id) AS total_pedidos
FROM clientes_ativos c
LEFT JOIN pedidos_2024 p ON c.id = p.cliente_id
GROUP BY c.nome;

/*
üí° VANTAGENS DAS CTEs:
   - Mais leg√≠veis que subconsultas aninhadas
   - Podem ser referenciadas m√∫ltiplas vezes
   - Facilitam manuten√ß√£o
   - Suportam recurs√£o
*/

================================================================================
PARTE 6: CTEs RECURSIVAS
================================================================================

-- CTE Recursiva: para hierarquias e √°rvores

-- Exemplo: hierarquia de funcion√°rios (gerente ‚Üí subordinados)
WITH RECURSIVE hierarquia AS (
    -- Caso base: gerentes sem superior
    SELECT id, nome, gerente_id, 1 AS nivel
    FROM funcionarios
    WHERE gerente_id IS NULL
    
    UNION ALL
    
    -- Caso recursivo: subordinados
    SELECT f.id, f.nome, f.gerente_id, h.nivel + 1
    FROM funcionarios f
    INNER JOIN hierarquia h ON f.gerente_id = h.id
)
SELECT * FROM hierarquia ORDER BY nivel, nome;

-- Gerar sequ√™ncia de n√∫meros:
WITH RECURSIVE numeros AS (
    SELECT 1 AS n
    UNION ALL
    SELECT n + 1 FROM numeros WHERE n < 10
)
SELECT * FROM numeros;
-- Resultado: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10

================================================================================
EXEMPLOS PR√ÅTICOS
================================================================================

-- Dashboard de vendas com CTEs:
WITH 
    vendas_mes AS (
        SELECT 
            EXTRACT(MONTH FROM data_pedido) AS mes,
            SUM(valor_total) AS total
        FROM pedidos
        WHERE EXTRACT(YEAR FROM data_pedido) = 2024
        GROUP BY EXTRACT(MONTH FROM data_pedido)
    ),
    melhores_clientes AS (
        SELECT 
            cliente_id,
            SUM(valor_total) AS total_gasto
        FROM pedidos
        GROUP BY cliente_id
        ORDER BY total_gasto DESC
        LIMIT 10
    )
SELECT 
    vm.mes,
    vm.total AS receita_mensal,
    (SELECT COUNT(*) FROM melhores_clientes) AS top_clientes
FROM vendas_mes vm;

================================================================================
EXERC√çCIOS PR√ÅTICOS
================================================================================

üí™ EXERC√çCIO 1: Subconsultas B√°sicas (10 min)
a) Produtos com pre√ßo acima da m√©dia geral
b) Funcion√°rios do departamento com mais funcion√°rios
c) Pedidos com valor acima da m√©dia
d) Clientes que nunca compraram (NOT IN ou NOT EXISTS)

üí™ EXERC√çCIO 2: Correlacionadas (15 min)
a) Funcion√°rios com sal√°rio acima da m√©dia do seu cargo
b) Produtos mais caros que a m√©dia da sua categoria
c) √öltimo pedido de cada cliente (use MAX)

üí™ EXERC√çCIO 3: CTEs (15 min)
a) Criar CTE com vendas por categoria, depois filtrar
b) Usar 2+ CTEs para criar relat√≥rio de vendas
c) CTE recursiva para gerar calend√°rio de 30 dias

üí™ DESAFIO:
Crie hierarquia completa de categorias (categoria ‚Üí subcategoria ‚Üí 
sub-subcategoria) usando CTE recursiva.

RESUMO:
‚Ä¢ Subconsultas em WHERE, FROM, SELECT
‚Ä¢ IN / NOT IN ‚Üí m√∫ltiplos valores
‚Ä¢ EXISTS / NOT EXISTS ‚Üí verificar exist√™ncia (mais eficiente)
‚Ä¢ Correlacionadas ‚Üí usam valor da query externa
‚Ä¢ CTEs (WITH) ‚Üí subconsultas nomeadas e leg√≠veis
‚Ä¢ CTEs recursivas ‚Üí hierarquias e sequ√™ncias

TAREFA: Exerc√≠cios 71-75 | PR√ìXIMA AULA: Views, Materialized Views, √çndices

================================================================================
FIM DA AULA 08
================================================================================
